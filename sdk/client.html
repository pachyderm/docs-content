<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pachyderm_sdk.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pachyderm_sdk.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import contextlib
import os
import json
from base64 import b64decode
from dataclasses import dataclass
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import Dict, Optional, Union
from urllib.parse import urlparse

import grpc

from .api.admin.extension import ApiStub as _AdminStub
from .api.auth import ApiStub as _AuthStub
from .api.debug import DebugStub as _DebugStub
from .api.enterprise import ApiStub as _EnterpriseStub
from .api.identity import ApiStub as _IdentityStub
from .api.license import ApiStub as _LicenseStub
from .api.pfs.extension import ApiStub as _PfsStub
from .api.pps.extension import ApiStub as _PpsStub
from .api.transaction.extension import ApiStub as _TransactionStub
from .api.version import ApiStub as _VersionStub, Version
from .constants import (
    AUTH_TOKEN_ENV,
    GRPC_CHANNEL_OPTIONS,
    OIDC_TOKEN_ENV,
    PACHD_SERVICE_HOST_ENV,
    PACHD_SERVICE_PORT_ENV,
)
from .errors import AuthServiceNotActivated, BadClusterDeploymentID, ConfigError
from .interceptor import MetadataClientInterceptor, MetadataType

__all__ = (&#34;Client&#34;, )


class Client:
    &#34;&#34;&#34;The :class:`.Client` class that users will primarily interact with.
    Initialize an instance with ``python_pachyderm.Client()``.

    To see documentation on the methods :class:`.Client` can call, refer to the
    `mixins` module.
    &#34;&#34;&#34;

    # Class variables for checking config
    env_config = &#34;PACH_CONFIG&#34;
    spout_config = Path(&#34;/pachctl/config.json&#34;)
    local_config = Path.home().joinpath(&#34;pachyderm/config.json&#34;)

    def __init__(
        self,
        host: str = &#39;localhost&#39;,
        port: int = 30650,
        auth_token: Optional[str] = None,
        root_certs: Optional[bytes] = None,
        transaction_id: str = None,
        tls: bool = False,
    ):
        &#34;&#34;&#34;
        Creates a Pachyderm client. If both files don&#39;t exist, a client
        with default settings is created.

        Parameters
        ----------
        host : str, optional
            The pachd host. Default is &#39;localhost&#39;, which is used with
            ``pachctl port-forward``.
        port : int, optional
            The port to connect to. Default is 30650.
        auth_token : str, optional
            The authentication token. Used if authentication is enabled on the
            cluster.
        root_certs : bytes, optional
            The PEM-encoded root certificates as byte string.
        transaction_id : str, optional
            The ID of the transaction to run operations on.
        tls : bool
            Whether TLS should be used. If `root_certs` are specified, they are
            used. Otherwise, we use the certs provided by certifi.
        &#34;&#34;&#34;
        if auth_token is None:
            auth_token = os.environ.get(AUTH_TOKEN_ENV)

        tls = tls or (root_certs is not None)
        if tls and root_certs is None:
            # load default certs if none are specified
            import certifi

            with open(certifi.where(), &#34;rb&#34;) as f:
                root_certs = f.read()

        self.address = &#34;{}:{}&#34;.format(host, port)
        self.root_certs = root_certs
        channel = _create_channel(
            self.address, self.root_certs, options=GRPC_CHANNEL_OPTIONS
        )

        self._auth_token = auth_token
        self._transaction_id = transaction_id
        self._metadata = self._build_metadata()
        self._channel = _apply_metadata_interceptor(channel, self._metadata)

        # See implementation for api layout.
        self._init_api()

        if not auth_token and (oidc_token := os.environ.get(OIDC_TOKEN_ENV)):
            self.auth_token = self.auth.authenticate(id_token=oidc_token)

    def _init_api(self):
        self.admin = _AdminStub(self._channel)
        self.auth = _AuthStub(self._channel)
        self.debug = _DebugStub(self._channel)
        self.enterprise = _EnterpriseStub(self._channel)
        self.identity = _IdentityStub(self._channel)
        self.license = _LicenseStub(self._channel)
        self.pfs = _PfsStub(self._channel)
        self.pps = _PpsStub(self._channel)
        self.transaction = _TransactionStub(
            self._channel,
            get_transaction_id=lambda: self.transaction_id,
            set_transaction_id=lambda value: setattr(self, &#34;transaction_id&#34;, value),
        )
        self._version_api = _VersionStub(self._channel)

    @classmethod
    def new_in_cluster(
        cls,
        auth_token: Optional[str] = None,
        transaction_id: Optional[str] = None
    ) -&gt; &#34;Client&#34;:
        &#34;&#34;&#34;Creates a Pachyderm client that operates within a Pachyderm cluster.

        Parameters
        ----------
        auth_token : str, optional
            The authentication token. Used if authentication is enabled on the
            cluster.
        transaction_id : str, optional
            The ID of the transaction to run operations on.

        Returns
        -------
        Client
            A python_pachyderm client instance.
        &#34;&#34;&#34;
        if cls.spout_config.exists():
            # TODO: Should we notify the user that we are using spout config?
            return cls.from_config(cls.spout_config)

        host = os.environ.get(PACHD_SERVICE_HOST_ENV)
        if host is None:
            raise RuntimeError(
                f&#34;Environment variable {PACHD_SERVICE_HOST_ENV} not set &#34;
                f&#34;-- cannot connect. Are you running in a cluster?&#34;
            )
        port = os.environ.get(PACHD_SERVICE_PORT_ENV)
        if port is None:
            raise RuntimeError(
                f&#34;Environment variable {PACHD_SERVICE_PORT_ENV} not set &#34;
                f&#34;-- cannot connect. Are you running in a cluster?&#34;
            )

        return cls(
            host=host,
            port=int(port),
            auth_token=auth_token,
            transaction_id=transaction_id,
        )

    @classmethod
    def from_pachd_address(
        cls,
        pachd_address: str,
        auth_token: str = None,
        root_certs: bytes = None,
        transaction_id: str = None,
    ) -&gt; &#34;Client&#34;:
        &#34;&#34;&#34;Creates a Pachyderm client from a given pachd address.

        Parameters
        ----------
        pachd_address : str
            The address of pachd server
        auth_token : str, optional
            The authentication token. Used if authentication is enabled on the
            cluster.
        root_certs : bytes, optional
            The PEM-encoded root certificates as byte string. If unspecified,
            this will load default certs from certifi.
        transaction_id : str, optional
            The ID of the transaction to run operations on.

        Returns
        -------
        Client
            A python_pachyderm client instance.
        &#34;&#34;&#34;
        if &#34;://&#34; not in pachd_address:
            pachd_address = &#34;grpc://{}&#34;.format(pachd_address)

        u = urlparse(pachd_address)

        if u.scheme not in (&#34;grpc&#34;, &#34;http&#34;, &#34;grpcs&#34;, &#34;https&#34;):
            raise ValueError(&#34;unrecognized pachd address scheme: {}&#34;.format(u.scheme))
        if u.path or u.params or u.query or u.fragment or u.username or u.password:
            raise ValueError(&#34;invalid pachd address&#34;)

        return cls(
            host=u.hostname,
            port=u.port,
            auth_token=auth_token,
            root_certs=root_certs,
            transaction_id=transaction_id,
            tls=u.scheme == &#34;grpcs&#34; or u.scheme == &#34;https&#34;,
        )

    @classmethod
    def from_config(cls, config_file: Union[Path, str]) -&gt; &#34;Client&#34;:
        &#34;&#34;&#34;Creates a Pachyderm client from a config file.

        Parameters
        ----------
        config_file : Union[Path, str]
            The path to a config json file.

        Returns
        -------
        Client
            A properly configured Client.
        &#34;&#34;&#34;
        # TODO: Should config_file be nullable?
        #  If null should we search for the local config?
        config = _ConfigFile(config_file)
        active_context = config.active_context
        client = cls.from_pachd_address(
            active_context.active_pachd_address,
            auth_token=active_context.session_token,
            root_certs=active_context.server_cas_decoded,
            transaction_id=active_context.active_transaction,
        )

        # Verify the deployment ID of the active context with the cluster.
        expected_deployment_id = active_context.cluster_deployment_id
        if expected_deployment_id:
            cluster_info = client.admin.inspect_cluster()
            if cluster_info.deployment_id != expected_deployment_id:
                raise BadClusterDeploymentID(
                    expected_deployment_id, cluster_info.deployment_id
                )

        return client

    @property
    def auth_token(self):
        return self._auth_token

    @auth_token.setter
    def auth_token(self, value):
        self._auth_token = value
        self._metadata = self._build_metadata()
        self._channel = _apply_metadata_interceptor(
            channel=_create_channel(
                self.address, self.root_certs, options=GRPC_CHANNEL_OPTIONS
            ),
            metadata=self._metadata,
        )
        self._init_api()

    @property
    def transaction_id(self):
        return self._transaction_id

    @transaction_id.setter
    def transaction_id(self, value):
        self._transaction_id = value
        self._metadata = self._build_metadata()
        self._channel = _apply_metadata_interceptor(
            channel=_create_channel(
                self.address, self.root_certs, options=GRPC_CHANNEL_OPTIONS
            ),
            metadata=self._metadata,
        )
        self._init_api()

    def _build_metadata(self):
        metadata = []
        if self._auth_token is not None:
            metadata.append((&#34;authn-token&#34;, self._auth_token))
        if self._transaction_id is not None:
            metadata.append((&#34;pach-transaction&#34;, self._transaction_id))
        return metadata

    def delete_all(self) -&gt; None:
        &#34;&#34;&#34;Delete all repos, commits, files, pipelines, and jobs.
        This resets the cluster to its initial state.
        &#34;&#34;&#34;
        # Try removing all identities if auth is activated.
        with contextlib.suppress(AuthServiceNotActivated):
            self.identity.delete_all()

        # Try deactivating auth if activated.
        with contextlib.suppress(AuthServiceNotActivated):
            self.auth.deactivate()

        # Try removing all licenses if auth is activated.
        with contextlib.suppress(AuthServiceNotActivated):
            self.license.delete_all()

        self.pps.delete_all()
        self.pfs.delete_all()
        self.transaction.delete_all()

    def get_version(self) -&gt; Version:
        return self._version_api.get_version()


def _apply_metadata_interceptor(
    channel: grpc.Channel, metadata: MetadataType
) -&gt; grpc.Channel:
    metadata_interceptor = MetadataClientInterceptor(metadata)
    return grpc.intercept_channel(channel, metadata_interceptor)


def _create_channel(
    address: str,
    root_certs: Optional[bytes],
    options: MetadataType,
) -&gt; grpc.Channel:
    if root_certs is not None:
        ssl = grpc.ssl_channel_credentials(root_certificates=root_certs)
        return grpc.secure_channel(address, ssl, options=options)
    return grpc.insecure_channel(address, options=options)


class _ConfigFile:

    def __init__(self, config_file: Union[Path, str]):
        config_file = Path(os.path.expanduser(config_file)).resolve()
        self._config_file_data = json.loads(config_file.read_bytes())

    @classmethod
    def from_bytes(cls, config_file_data: bytes):
        with NamedTemporaryFile() as temp_config_file:
            temp_config_file.write(config_file_data)
            return cls(temp_config_file.name)

    @property
    def user_id(self) -&gt; str:
        return self._config_file_data[&#34;user_id&#34;]

    @property
    def active_context(self) -&gt; &#34;_Context&#34;:
        active_context_name = self._config_file_data[&#34;v2&#34;][&#34;active_context&#34;]
        contexts = self._config_file_data[&#34;v2&#34;][&#34;contexts&#34;]
        if active_context_name not in contexts:
            raise ConfigError(f&#34;active context not found: {active_context_name}&#34;)
        return _Context(**contexts[active_context_name])

    @property
    def active_enterprise_context(self) -&gt; &#34;_Context&#34;:
        context_name = self._config_file_data[&#34;v2&#34;].get(&#34;active_enterprise_context&#34;)
        if context_name is None:
            raise ConfigError(&#34;active enterprise context is not specified&#34;)
        contexts = self._config_file_data[&#34;v2&#34;][&#34;contexts&#34;]
        if context_name not in contexts:
            raise ConfigError(f&#34;active enterprise context not found: {context_name}&#34;)
        return _Context(**contexts[context_name])


@dataclass
class _Context:
    source: Optional[int] = None
    &#34;&#34;&#34;An integer that specifies where the config came from. 
    This parameter is for internal use only and should not be modified.&#34;&#34;&#34;

    pachd_address: Optional[str] = None
    &#34;&#34;&#34;A host:port specification for connecting to pachd.&#34;&#34;&#34;

    server_cas: Optional[str] = None
    &#34;&#34;&#34;Trusted root certificates for the cluster, formatted as a 
    base64-encoded PEM. This is only set when TLS is enabled.&#34;&#34;&#34;

    session_token: Optional[str] = None
    &#34;&#34;&#34;A secret token identifying the current user within their pachyderm
    cluster. This is included in all RPCs and used to determine if a user&#39;s
    actions are authorized. This is only set when auth is enabled.&#34;&#34;&#34;

    active_transaction: Optional[str] = None
    &#34;&#34;&#34;The currently active transaction for batching together commands.&#34;&#34;&#34;

    cluster_name: Optional[str] = None
    &#34;&#34;&#34;The name of the underlying Kubernetes cluster.&#34;&#34;&#34;

    auth_info: Optional[str] = None
    &#34;&#34;&#34;The name of the underlying Kubernetes cluster’s auth credentials&#34;&#34;&#34;

    namespace: Optional[str] = None
    &#34;&#34;&#34;The underlying Kubernetes cluster’s namespace&#34;&#34;&#34;

    cluster_deployment_id: Optional[str] = None
    &#34;&#34;&#34;The pachyderm cluster deployment ID that is used to ensure the
    operations run on the expected cluster.&#34;&#34;&#34;

    project: Optional[str] = None

    enterprise_server: bool = False
    &#34;&#34;&#34;Whether the context represents an enterprise server.&#34;&#34;&#34;

    port_forwarders: Dict[str, int] = None
    &#34;&#34;&#34;A mapping of service name -&gt; local port.&#34;&#34;&#34;

    @property
    def active_pachd_address(self) -&gt; str:
        &#34;&#34;&#34;This pachd factors in port-forwarding. &#34;&#34;&#34;
        if self.pachd_address is None:
            port = 30650
            if self.port_forwarders:
                port = self.port_forwarders.get(&#39;pachd&#39;, 30650)
            return f&#34;grpc://localhost:{port}&#34;
        return self.pachd_address

    @property
    def server_cas_decoded(self) -&gt; Optional[bytes]:
        &#34;&#34;&#34;The base64 decoded root certificates in PEM format, if they exist.&#34;&#34;&#34;
        if self.server_cas:
            return b64decode(bytes(self.server_cas, &#34;utf-8&#34;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pachyderm_sdk.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>host: str = 'localhost', port: int = 30650, auth_token: Optional[str] = None, root_certs: Optional[bytes] = None, transaction_id: str = None, tls: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The :class:<code>.<a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></code> class that users will primarily interact with.
Initialize an instance with <code>python_pachyderm.Client()</code>.</p>
<p>To see documentation on the methods :class:<code>.<a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></code> can call, refer to the
<code>mixins</code> module.</p>
<p>Creates a Pachyderm client. If both files don't exist, a client
with default settings is created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The pachd host. Default is 'localhost', which is used with
<code>pachctl port-forward</code>.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The port to connect to. Default is 30650.</dd>
<dt><strong><code>auth_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The authentication token. Used if authentication is enabled on the
cluster.</dd>
<dt><strong><code>root_certs</code></strong> :&ensp;<code>bytes</code>, optional</dt>
<dd>The PEM-encoded root certificates as byte string.</dd>
<dt><strong><code>transaction_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the transaction to run operations on.</dd>
<dt><strong><code>tls</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether TLS should be used. If <code>root_certs</code> are specified, they are
used. Otherwise, we use the certs provided by certifi.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;The :class:`.Client` class that users will primarily interact with.
    Initialize an instance with ``python_pachyderm.Client()``.

    To see documentation on the methods :class:`.Client` can call, refer to the
    `mixins` module.
    &#34;&#34;&#34;

    # Class variables for checking config
    env_config = &#34;PACH_CONFIG&#34;
    spout_config = Path(&#34;/pachctl/config.json&#34;)
    local_config = Path.home().joinpath(&#34;pachyderm/config.json&#34;)

    def __init__(
        self,
        host: str = &#39;localhost&#39;,
        port: int = 30650,
        auth_token: Optional[str] = None,
        root_certs: Optional[bytes] = None,
        transaction_id: str = None,
        tls: bool = False,
    ):
        &#34;&#34;&#34;
        Creates a Pachyderm client. If both files don&#39;t exist, a client
        with default settings is created.

        Parameters
        ----------
        host : str, optional
            The pachd host. Default is &#39;localhost&#39;, which is used with
            ``pachctl port-forward``.
        port : int, optional
            The port to connect to. Default is 30650.
        auth_token : str, optional
            The authentication token. Used if authentication is enabled on the
            cluster.
        root_certs : bytes, optional
            The PEM-encoded root certificates as byte string.
        transaction_id : str, optional
            The ID of the transaction to run operations on.
        tls : bool
            Whether TLS should be used. If `root_certs` are specified, they are
            used. Otherwise, we use the certs provided by certifi.
        &#34;&#34;&#34;
        if auth_token is None:
            auth_token = os.environ.get(AUTH_TOKEN_ENV)

        tls = tls or (root_certs is not None)
        if tls and root_certs is None:
            # load default certs if none are specified
            import certifi

            with open(certifi.where(), &#34;rb&#34;) as f:
                root_certs = f.read()

        self.address = &#34;{}:{}&#34;.format(host, port)
        self.root_certs = root_certs
        channel = _create_channel(
            self.address, self.root_certs, options=GRPC_CHANNEL_OPTIONS
        )

        self._auth_token = auth_token
        self._transaction_id = transaction_id
        self._metadata = self._build_metadata()
        self._channel = _apply_metadata_interceptor(channel, self._metadata)

        # See implementation for api layout.
        self._init_api()

        if not auth_token and (oidc_token := os.environ.get(OIDC_TOKEN_ENV)):
            self.auth_token = self.auth.authenticate(id_token=oidc_token)

    def _init_api(self):
        self.admin = _AdminStub(self._channel)
        self.auth = _AuthStub(self._channel)
        self.debug = _DebugStub(self._channel)
        self.enterprise = _EnterpriseStub(self._channel)
        self.identity = _IdentityStub(self._channel)
        self.license = _LicenseStub(self._channel)
        self.pfs = _PfsStub(self._channel)
        self.pps = _PpsStub(self._channel)
        self.transaction = _TransactionStub(
            self._channel,
            get_transaction_id=lambda: self.transaction_id,
            set_transaction_id=lambda value: setattr(self, &#34;transaction_id&#34;, value),
        )
        self._version_api = _VersionStub(self._channel)

    @classmethod
    def new_in_cluster(
        cls,
        auth_token: Optional[str] = None,
        transaction_id: Optional[str] = None
    ) -&gt; &#34;Client&#34;:
        &#34;&#34;&#34;Creates a Pachyderm client that operates within a Pachyderm cluster.

        Parameters
        ----------
        auth_token : str, optional
            The authentication token. Used if authentication is enabled on the
            cluster.
        transaction_id : str, optional
            The ID of the transaction to run operations on.

        Returns
        -------
        Client
            A python_pachyderm client instance.
        &#34;&#34;&#34;
        if cls.spout_config.exists():
            # TODO: Should we notify the user that we are using spout config?
            return cls.from_config(cls.spout_config)

        host = os.environ.get(PACHD_SERVICE_HOST_ENV)
        if host is None:
            raise RuntimeError(
                f&#34;Environment variable {PACHD_SERVICE_HOST_ENV} not set &#34;
                f&#34;-- cannot connect. Are you running in a cluster?&#34;
            )
        port = os.environ.get(PACHD_SERVICE_PORT_ENV)
        if port is None:
            raise RuntimeError(
                f&#34;Environment variable {PACHD_SERVICE_PORT_ENV} not set &#34;
                f&#34;-- cannot connect. Are you running in a cluster?&#34;
            )

        return cls(
            host=host,
            port=int(port),
            auth_token=auth_token,
            transaction_id=transaction_id,
        )

    @classmethod
    def from_pachd_address(
        cls,
        pachd_address: str,
        auth_token: str = None,
        root_certs: bytes = None,
        transaction_id: str = None,
    ) -&gt; &#34;Client&#34;:
        &#34;&#34;&#34;Creates a Pachyderm client from a given pachd address.

        Parameters
        ----------
        pachd_address : str
            The address of pachd server
        auth_token : str, optional
            The authentication token. Used if authentication is enabled on the
            cluster.
        root_certs : bytes, optional
            The PEM-encoded root certificates as byte string. If unspecified,
            this will load default certs from certifi.
        transaction_id : str, optional
            The ID of the transaction to run operations on.

        Returns
        -------
        Client
            A python_pachyderm client instance.
        &#34;&#34;&#34;
        if &#34;://&#34; not in pachd_address:
            pachd_address = &#34;grpc://{}&#34;.format(pachd_address)

        u = urlparse(pachd_address)

        if u.scheme not in (&#34;grpc&#34;, &#34;http&#34;, &#34;grpcs&#34;, &#34;https&#34;):
            raise ValueError(&#34;unrecognized pachd address scheme: {}&#34;.format(u.scheme))
        if u.path or u.params or u.query or u.fragment or u.username or u.password:
            raise ValueError(&#34;invalid pachd address&#34;)

        return cls(
            host=u.hostname,
            port=u.port,
            auth_token=auth_token,
            root_certs=root_certs,
            transaction_id=transaction_id,
            tls=u.scheme == &#34;grpcs&#34; or u.scheme == &#34;https&#34;,
        )

    @classmethod
    def from_config(cls, config_file: Union[Path, str]) -&gt; &#34;Client&#34;:
        &#34;&#34;&#34;Creates a Pachyderm client from a config file.

        Parameters
        ----------
        config_file : Union[Path, str]
            The path to a config json file.

        Returns
        -------
        Client
            A properly configured Client.
        &#34;&#34;&#34;
        # TODO: Should config_file be nullable?
        #  If null should we search for the local config?
        config = _ConfigFile(config_file)
        active_context = config.active_context
        client = cls.from_pachd_address(
            active_context.active_pachd_address,
            auth_token=active_context.session_token,
            root_certs=active_context.server_cas_decoded,
            transaction_id=active_context.active_transaction,
        )

        # Verify the deployment ID of the active context with the cluster.
        expected_deployment_id = active_context.cluster_deployment_id
        if expected_deployment_id:
            cluster_info = client.admin.inspect_cluster()
            if cluster_info.deployment_id != expected_deployment_id:
                raise BadClusterDeploymentID(
                    expected_deployment_id, cluster_info.deployment_id
                )

        return client

    @property
    def auth_token(self):
        return self._auth_token

    @auth_token.setter
    def auth_token(self, value):
        self._auth_token = value
        self._metadata = self._build_metadata()
        self._channel = _apply_metadata_interceptor(
            channel=_create_channel(
                self.address, self.root_certs, options=GRPC_CHANNEL_OPTIONS
            ),
            metadata=self._metadata,
        )
        self._init_api()

    @property
    def transaction_id(self):
        return self._transaction_id

    @transaction_id.setter
    def transaction_id(self, value):
        self._transaction_id = value
        self._metadata = self._build_metadata()
        self._channel = _apply_metadata_interceptor(
            channel=_create_channel(
                self.address, self.root_certs, options=GRPC_CHANNEL_OPTIONS
            ),
            metadata=self._metadata,
        )
        self._init_api()

    def _build_metadata(self):
        metadata = []
        if self._auth_token is not None:
            metadata.append((&#34;authn-token&#34;, self._auth_token))
        if self._transaction_id is not None:
            metadata.append((&#34;pach-transaction&#34;, self._transaction_id))
        return metadata

    def delete_all(self) -&gt; None:
        &#34;&#34;&#34;Delete all repos, commits, files, pipelines, and jobs.
        This resets the cluster to its initial state.
        &#34;&#34;&#34;
        # Try removing all identities if auth is activated.
        with contextlib.suppress(AuthServiceNotActivated):
            self.identity.delete_all()

        # Try deactivating auth if activated.
        with contextlib.suppress(AuthServiceNotActivated):
            self.auth.deactivate()

        # Try removing all licenses if auth is activated.
        with contextlib.suppress(AuthServiceNotActivated):
            self.license.delete_all()

        self.pps.delete_all()
        self.pfs.delete_all()
        self.transaction.delete_all()

    def get_version(self) -&gt; Version:
        return self._version_api.get_version()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pachyderm_sdk.client.Client.env_config"><code class="name">var <span class="ident">env_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pachyderm_sdk.client.Client.local_config"><code class="name">var <span class="ident">local_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pachyderm_sdk.client.Client.spout_config"><code class="name">var <span class="ident">spout_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pachyderm_sdk.client.Client.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config_file: Union[pathlib.Path, str]) ‑> <a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client from a config file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config_file</code></strong> :&ensp;<code>Union[Path, str]</code></dt>
<dd>The path to a config json file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></code></dt>
<dd>A properly configured Client.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_config(cls, config_file: Union[Path, str]) -&gt; &#34;Client&#34;:
    &#34;&#34;&#34;Creates a Pachyderm client from a config file.

    Parameters
    ----------
    config_file : Union[Path, str]
        The path to a config json file.

    Returns
    -------
    Client
        A properly configured Client.
    &#34;&#34;&#34;
    # TODO: Should config_file be nullable?
    #  If null should we search for the local config?
    config = _ConfigFile(config_file)
    active_context = config.active_context
    client = cls.from_pachd_address(
        active_context.active_pachd_address,
        auth_token=active_context.session_token,
        root_certs=active_context.server_cas_decoded,
        transaction_id=active_context.active_transaction,
    )

    # Verify the deployment ID of the active context with the cluster.
    expected_deployment_id = active_context.cluster_deployment_id
    if expected_deployment_id:
        cluster_info = client.admin.inspect_cluster()
        if cluster_info.deployment_id != expected_deployment_id:
            raise BadClusterDeploymentID(
                expected_deployment_id, cluster_info.deployment_id
            )

    return client</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.client.Client.from_pachd_address"><code class="name flex">
<span>def <span class="ident">from_pachd_address</span></span>(<span>pachd_address: str, auth_token: str = None, root_certs: bytes = None, transaction_id: str = None) ‑> <a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client from a given pachd address.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pachd_address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address of pachd server</dd>
<dt><strong><code>auth_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The authentication token. Used if authentication is enabled on the
cluster.</dd>
<dt><strong><code>root_certs</code></strong> :&ensp;<code>bytes</code>, optional</dt>
<dd>The PEM-encoded root certificates as byte string. If unspecified,
this will load default certs from certifi.</dd>
<dt><strong><code>transaction_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the transaction to run operations on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></code></dt>
<dd>A python_pachyderm client instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_pachd_address(
    cls,
    pachd_address: str,
    auth_token: str = None,
    root_certs: bytes = None,
    transaction_id: str = None,
) -&gt; &#34;Client&#34;:
    &#34;&#34;&#34;Creates a Pachyderm client from a given pachd address.

    Parameters
    ----------
    pachd_address : str
        The address of pachd server
    auth_token : str, optional
        The authentication token. Used if authentication is enabled on the
        cluster.
    root_certs : bytes, optional
        The PEM-encoded root certificates as byte string. If unspecified,
        this will load default certs from certifi.
    transaction_id : str, optional
        The ID of the transaction to run operations on.

    Returns
    -------
    Client
        A python_pachyderm client instance.
    &#34;&#34;&#34;
    if &#34;://&#34; not in pachd_address:
        pachd_address = &#34;grpc://{}&#34;.format(pachd_address)

    u = urlparse(pachd_address)

    if u.scheme not in (&#34;grpc&#34;, &#34;http&#34;, &#34;grpcs&#34;, &#34;https&#34;):
        raise ValueError(&#34;unrecognized pachd address scheme: {}&#34;.format(u.scheme))
    if u.path or u.params or u.query or u.fragment or u.username or u.password:
        raise ValueError(&#34;invalid pachd address&#34;)

    return cls(
        host=u.hostname,
        port=u.port,
        auth_token=auth_token,
        root_certs=root_certs,
        transaction_id=transaction_id,
        tls=u.scheme == &#34;grpcs&#34; or u.scheme == &#34;https&#34;,
    )</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.client.Client.new_in_cluster"><code class="name flex">
<span>def <span class="ident">new_in_cluster</span></span>(<span>auth_token: Optional[str] = None, transaction_id: Optional[str] = None) ‑> <a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client that operates within a Pachyderm cluster.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>auth_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The authentication token. Used if authentication is enabled on the
cluster.</dd>
<dt><strong><code>transaction_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the transaction to run operations on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></code></dt>
<dd>A python_pachyderm client instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new_in_cluster(
    cls,
    auth_token: Optional[str] = None,
    transaction_id: Optional[str] = None
) -&gt; &#34;Client&#34;:
    &#34;&#34;&#34;Creates a Pachyderm client that operates within a Pachyderm cluster.

    Parameters
    ----------
    auth_token : str, optional
        The authentication token. Used if authentication is enabled on the
        cluster.
    transaction_id : str, optional
        The ID of the transaction to run operations on.

    Returns
    -------
    Client
        A python_pachyderm client instance.
    &#34;&#34;&#34;
    if cls.spout_config.exists():
        # TODO: Should we notify the user that we are using spout config?
        return cls.from_config(cls.spout_config)

    host = os.environ.get(PACHD_SERVICE_HOST_ENV)
    if host is None:
        raise RuntimeError(
            f&#34;Environment variable {PACHD_SERVICE_HOST_ENV} not set &#34;
            f&#34;-- cannot connect. Are you running in a cluster?&#34;
        )
    port = os.environ.get(PACHD_SERVICE_PORT_ENV)
    if port is None:
        raise RuntimeError(
            f&#34;Environment variable {PACHD_SERVICE_PORT_ENV} not set &#34;
            f&#34;-- cannot connect. Are you running in a cluster?&#34;
        )

    return cls(
        host=host,
        port=int(port),
        auth_token=auth_token,
        transaction_id=transaction_id,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pachyderm_sdk.client.Client.auth_token"><code class="name">var <span class="ident">auth_token</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth_token(self):
    return self._auth_token</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.client.Client.transaction_id"><code class="name">var <span class="ident">transaction_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transaction_id(self):
    return self._transaction_id</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pachyderm_sdk.client.Client.delete_all"><code class="name flex">
<span>def <span class="ident">delete_all</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all repos, commits, files, pipelines, and jobs.
This resets the cluster to its initial state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_all(self) -&gt; None:
    &#34;&#34;&#34;Delete all repos, commits, files, pipelines, and jobs.
    This resets the cluster to its initial state.
    &#34;&#34;&#34;
    # Try removing all identities if auth is activated.
    with contextlib.suppress(AuthServiceNotActivated):
        self.identity.delete_all()

    # Try deactivating auth if activated.
    with contextlib.suppress(AuthServiceNotActivated):
        self.auth.deactivate()

    # Try removing all licenses if auth is activated.
    with contextlib.suppress(AuthServiceNotActivated):
        self.license.delete_all()

    self.pps.delete_all()
    self.pfs.delete_all()
    self.transaction.delete_all()</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.client.Client.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>self) ‑> <a title="pachyderm_sdk.api.version.Version" href="api/version/index.html#pachyderm_sdk.api.version.Version">Version</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version(self) -&gt; Version:
    return self._version_api.get_version()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pachyderm_sdk" href="index.html">pachyderm_sdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pachyderm_sdk.client.Client" href="#pachyderm_sdk.client.Client">Client</a></code></h4>
<ul class="two-column">
<li><code><a title="pachyderm_sdk.client.Client.auth_token" href="#pachyderm_sdk.client.Client.auth_token">auth_token</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.delete_all" href="#pachyderm_sdk.client.Client.delete_all">delete_all</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.env_config" href="#pachyderm_sdk.client.Client.env_config">env_config</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.from_config" href="#pachyderm_sdk.client.Client.from_config">from_config</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.from_pachd_address" href="#pachyderm_sdk.client.Client.from_pachd_address">from_pachd_address</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.get_version" href="#pachyderm_sdk.client.Client.get_version">get_version</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.local_config" href="#pachyderm_sdk.client.Client.local_config">local_config</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.new_in_cluster" href="#pachyderm_sdk.client.Client.new_in_cluster">new_in_cluster</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.spout_config" href="#pachyderm_sdk.client.Client.spout_config">spout_config</a></code></li>
<li><code><a title="pachyderm_sdk.client.Client.transaction_id" href="#pachyderm_sdk.client.Client.transaction_id">transaction_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>