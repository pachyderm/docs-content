<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pachyderm_sdk.api.pfs.file API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pachyderm_sdk.api.pfs.file</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import tarfile
from io import RawIOBase
from typing import BinaryIO, Iterator, TYPE_CHECKING

if TYPE_CHECKING:
    from _typeshed import WriteableBuffer

import grpc
from betterproto import BytesValue


class PFSTarFile(tarfile.TarFile):
    &#34;&#34;&#34;Wrapper to allow reading a TAR file from PFS.

    See the tarfile.TarFile class for more information on the supported methods.
    &#34;&#34;&#34;

    def __iter__(self):
        for tarinfo in super().__iter__():
            if os.path.isabs(tarinfo.path):
                # Hack to prevent extraction to absolute paths.
                tarinfo.path = tarinfo.path[1:]
            if tarinfo.mode == 0:
                # Hack to prevent writing files with no permissions.
                tarinfo.mode = 0o700
            yield tarinfo


class PFSFile(RawIOBase, BinaryIO):
    &#34;&#34;&#34;File-like objects containing content of a file stored in PFS.

    The data is read from an open gRPC stream, any connection error will close the file.

    Notes
    -----
    The following links wer instrumental to understanding how to implement a pythonic
    file object:
      * https://docs.python.org/3/library/io.html
      * https://github.com/python/cpython/blob/3.11/Lib/_pyio.py

    Examples
    --------
    &gt;&gt;&gt; # client.pfs.pfs_file() returns a PFSFile
    &gt;&gt;&gt; import shutil
    &gt;&gt;&gt; from pachyderm_sdk import Client
    &gt;&gt;&gt; from pachyderm_sdk.api import pfs
    &gt;&gt;&gt;
    &gt;&gt;&gt; client: Client
    &gt;&gt;&gt; file = pfs.File.from_uri(&#34;montage@master:/montage.png&#34;)
    &gt;&gt;&gt; source_file = client.pfs.pfs_file(file=file)
    &gt;&gt;&gt; with open(&#34;montage.png&#34;, &#34;wb&#34;) as dest_file:
    &gt;&gt;&gt;     shutil.copyfileobj(source_file, dest_file)
    ...
    &gt;&gt;&gt; with client.pfs.pfs_file(file=file) as pfs_file:
    &gt;&gt;&gt;     contents = pfs_file.read()
    &#34;&#34;&#34;

    def __init__(self, stream: Iterator[BytesValue]):
        self._stream = stream
        self._buffer = bytearray()

        try:
            self.peek()
        except grpc.RpcError as err:
            raise ValueError(
                &#34;Error instantiating PFSFile -- see triggering exception&#34;
            ) from err

    def __enter__(self) -&gt; &#34;PFSFile&#34;:
        return self

    def readinto(self, buffer: &#34;WriteableBuffer&#34;) -&gt; int:
        &#34;&#34;&#34;Read bytes into a pre-allocated writeable buffer.

        Returns an int representing the number of bytes read.

        Note: This method is the only method that needs to be implemented in order
          to support the read(), readall(), readline(), etc. methods.
        &#34;&#34;&#34;
        if self.closed:
            raise ValueError(&#34;I/O operation on closed file.&#34;)
        size = len(buffer)
        if len(self._buffer) &lt; size:
            try:
                for message in self._stream:
                    self._buffer.extend(message.value)
                    if len(self._buffer) &gt;= size:
                        break
            except grpc.RpcError as err:
                self.close()
                raise err

        size = min(size, len(self._buffer))
        buffer[:size], self._buffer[:size] = self._buffer[:size], b&#34;&#34;
        return size

    def peek(self, size: int = 0) -&gt; bytes:
        &#34;&#34;&#34;Returns bytes from the stream without advancing the read position.
        At most one single read on the raw stream is done to satisfy the call.
        The number of bytes returned may be less than requested.&#34;&#34;&#34;
        if self.closed:
            raise ValueError(&#34;I/O operation on closed file.&#34;)
        if len(self._buffer) == 0:
            try:
                message = next(self._stream)
            except grpc.RpcError as err:
                self.close()
                raise err
            except StopIteration:
                return b&#34;&#34;
            self._buffer[:] = message.value
        return bytes(self._buffer[:size])

    def close(self) -&gt; None:
        &#34;&#34;&#34;Closes the PFSFile and cancels the gRPC stream.&#34;&#34;&#34;
        if hasattr(self, &#34;_stream&#34;):
            del self._stream
        super().close()

    def readable(self) -&gt; bool:
        return not self.closed</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pachyderm_sdk.api.pfs.file.PFSTarFile"><code class="flex name class">
<span>class <span class="ident">PFSTarFile</span></span>
<span>(</span><span>name=None, mode='r', fileobj=None, format=None, tarinfo=None, dereference=None, ignore_zeros=None, encoding=None, errors='surrogateescape', pax_headers=None, debug=None, errorlevel=None, copybufsize=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper to allow reading a TAR file from PFS.</p>
<p>See the tarfile.TarFile class for more information on the supported methods.</p>
<p>Open an (uncompressed) tar archive <code>name'.</code>mode' is either 'r' to
read from an existing archive, 'a' to append data to an existing
file or 'w' to create a new file overwriting an existing one. <code>mode'
defaults to 'r'.
If</code>fileobj' is given, it is used for reading or writing data. If it
can be determined, <code>mode' is overridden by</code>fileobj's mode.
`fileobj' is not closed, when TarFile is closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PFSTarFile(tarfile.TarFile):
    &#34;&#34;&#34;Wrapper to allow reading a TAR file from PFS.

    See the tarfile.TarFile class for more information on the supported methods.
    &#34;&#34;&#34;

    def __iter__(self):
        for tarinfo in super().__iter__():
            if os.path.isabs(tarinfo.path):
                # Hack to prevent extraction to absolute paths.
                tarinfo.path = tarinfo.path[1:]
            if tarinfo.mode == 0:
                # Hack to prevent writing files with no permissions.
                tarinfo.mode = 0o700
            yield tarinfo</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tarfile.TarFile</li>
</ul>
</dd>
<dt id="pachyderm_sdk.api.pfs.file.PFSFile"><code class="flex name class">
<span>class <span class="ident">PFSFile</span></span>
<span>(</span><span>stream: Iterator[betterproto.lib.google.protobuf.BytesValue])</span>
</code></dt>
<dd>
<div class="desc"><p>File-like objects containing content of a file stored in PFS.</p>
<p>The data is read from an open gRPC stream, any connection error will close the file.</p>
<h2 id="notes">Notes</h2>
<p>The following links wer instrumental to understanding how to implement a pythonic
file object:
* <a href="https://docs.python.org/3/library/io.html">https://docs.python.org/3/library/io.html</a>
* <a href="https://github.com/python/cpython/blob/3.11/Lib/_pyio.py">https://github.com/python/cpython/blob/3.11/Lib/_pyio.py</a></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # client.pfs.pfs_file() returns a PFSFile
&gt;&gt;&gt; import shutil
&gt;&gt;&gt; from pachyderm_sdk import Client
&gt;&gt;&gt; from pachyderm_sdk.api import pfs
&gt;&gt;&gt;
&gt;&gt;&gt; client: Client
&gt;&gt;&gt; file = pfs.File.from_uri(&quot;montage@master:/montage.png&quot;)
&gt;&gt;&gt; source_file = client.pfs.pfs_file(file=file)
&gt;&gt;&gt; with open(&quot;montage.png&quot;, &quot;wb&quot;) as dest_file:
&gt;&gt;&gt;     shutil.copyfileobj(source_file, dest_file)
...
&gt;&gt;&gt; with client.pfs.pfs_file(file=file) as pfs_file:
&gt;&gt;&gt;     contents = pfs_file.read()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PFSFile(RawIOBase, BinaryIO):
    &#34;&#34;&#34;File-like objects containing content of a file stored in PFS.

    The data is read from an open gRPC stream, any connection error will close the file.

    Notes
    -----
    The following links wer instrumental to understanding how to implement a pythonic
    file object:
      * https://docs.python.org/3/library/io.html
      * https://github.com/python/cpython/blob/3.11/Lib/_pyio.py

    Examples
    --------
    &gt;&gt;&gt; # client.pfs.pfs_file() returns a PFSFile
    &gt;&gt;&gt; import shutil
    &gt;&gt;&gt; from pachyderm_sdk import Client
    &gt;&gt;&gt; from pachyderm_sdk.api import pfs
    &gt;&gt;&gt;
    &gt;&gt;&gt; client: Client
    &gt;&gt;&gt; file = pfs.File.from_uri(&#34;montage@master:/montage.png&#34;)
    &gt;&gt;&gt; source_file = client.pfs.pfs_file(file=file)
    &gt;&gt;&gt; with open(&#34;montage.png&#34;, &#34;wb&#34;) as dest_file:
    &gt;&gt;&gt;     shutil.copyfileobj(source_file, dest_file)
    ...
    &gt;&gt;&gt; with client.pfs.pfs_file(file=file) as pfs_file:
    &gt;&gt;&gt;     contents = pfs_file.read()
    &#34;&#34;&#34;

    def __init__(self, stream: Iterator[BytesValue]):
        self._stream = stream
        self._buffer = bytearray()

        try:
            self.peek()
        except grpc.RpcError as err:
            raise ValueError(
                &#34;Error instantiating PFSFile -- see triggering exception&#34;
            ) from err

    def __enter__(self) -&gt; &#34;PFSFile&#34;:
        return self

    def readinto(self, buffer: &#34;WriteableBuffer&#34;) -&gt; int:
        &#34;&#34;&#34;Read bytes into a pre-allocated writeable buffer.

        Returns an int representing the number of bytes read.

        Note: This method is the only method that needs to be implemented in order
          to support the read(), readall(), readline(), etc. methods.
        &#34;&#34;&#34;
        if self.closed:
            raise ValueError(&#34;I/O operation on closed file.&#34;)
        size = len(buffer)
        if len(self._buffer) &lt; size:
            try:
                for message in self._stream:
                    self._buffer.extend(message.value)
                    if len(self._buffer) &gt;= size:
                        break
            except grpc.RpcError as err:
                self.close()
                raise err

        size = min(size, len(self._buffer))
        buffer[:size], self._buffer[:size] = self._buffer[:size], b&#34;&#34;
        return size

    def peek(self, size: int = 0) -&gt; bytes:
        &#34;&#34;&#34;Returns bytes from the stream without advancing the read position.
        At most one single read on the raw stream is done to satisfy the call.
        The number of bytes returned may be less than requested.&#34;&#34;&#34;
        if self.closed:
            raise ValueError(&#34;I/O operation on closed file.&#34;)
        if len(self._buffer) == 0:
            try:
                message = next(self._stream)
            except grpc.RpcError as err:
                self.close()
                raise err
            except StopIteration:
                return b&#34;&#34;
            self._buffer[:] = message.value
        return bytes(self._buffer[:size])

    def close(self) -&gt; None:
        &#34;&#34;&#34;Closes the PFSFile and cancels the gRPC stream.&#34;&#34;&#34;
        if hasattr(self, &#34;_stream&#34;):
            del self._stream
        super().close()

    def readable(self) -&gt; bool:
        return not self.closed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>io.RawIOBase</li>
<li>_io._RawIOBase</li>
<li>io.IOBase</li>
<li>_io._IOBase</li>
<li>typing.BinaryIO</li>
<li>typing.IO</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pachyderm_sdk.api.pfs.file.PFSFile.readinto"><code class="name flex">
<span>def <span class="ident">readinto</span></span>(<span>self, buffer: WriteableBuffer) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Read bytes into a pre-allocated writeable buffer.</p>
<p>Returns an int representing the number of bytes read.</p>
<p>Note: This method is the only method that needs to be implemented in order
to support the read(), readall(), readline(), etc. methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readinto(self, buffer: &#34;WriteableBuffer&#34;) -&gt; int:
    &#34;&#34;&#34;Read bytes into a pre-allocated writeable buffer.

    Returns an int representing the number of bytes read.

    Note: This method is the only method that needs to be implemented in order
      to support the read(), readall(), readline(), etc. methods.
    &#34;&#34;&#34;
    if self.closed:
        raise ValueError(&#34;I/O operation on closed file.&#34;)
    size = len(buffer)
    if len(self._buffer) &lt; size:
        try:
            for message in self._stream:
                self._buffer.extend(message.value)
                if len(self._buffer) &gt;= size:
                    break
        except grpc.RpcError as err:
            self.close()
            raise err

    size = min(size, len(self._buffer))
    buffer[:size], self._buffer[:size] = self._buffer[:size], b&#34;&#34;
    return size</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.api.pfs.file.PFSFile.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, size: int = 0) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns bytes from the stream without advancing the read position.
At most one single read on the raw stream is done to satisfy the call.
The number of bytes returned may be less than requested.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self, size: int = 0) -&gt; bytes:
    &#34;&#34;&#34;Returns bytes from the stream without advancing the read position.
    At most one single read on the raw stream is done to satisfy the call.
    The number of bytes returned may be less than requested.&#34;&#34;&#34;
    if self.closed:
        raise ValueError(&#34;I/O operation on closed file.&#34;)
    if len(self._buffer) == 0:
        try:
            message = next(self._stream)
        except grpc.RpcError as err:
            self.close()
            raise err
        except StopIteration:
            return b&#34;&#34;
        self._buffer[:] = message.value
    return bytes(self._buffer[:size])</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.api.pfs.file.PFSFile.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the PFSFile and cancels the gRPC stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;Closes the PFSFile and cancels the gRPC stream.&#34;&#34;&#34;
    if hasattr(self, &#34;_stream&#34;):
        del self._stream
    super().close()</code></pre>
</details>
</dd>
<dt id="pachyderm_sdk.api.pfs.file.PFSFile.readable"><code class="name flex">
<span>def <span class="ident">readable</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether object was opened for reading.</p>
<p>If False, read() will raise OSError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readable(self) -&gt; bool:
    return not self.closed</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<style> img { max-width: 50%; } </style>
<img src="https://raw.githubusercontent.com/pachyderm/pachyderm/master/Pachyderm_Icon-01.svg" alt="">
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pachyderm_sdk.api.pfs" href="index.html">pachyderm_sdk.api.pfs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pachyderm_sdk.api.pfs.file.PFSTarFile" href="#pachyderm_sdk.api.pfs.file.PFSTarFile">PFSTarFile</a></code></h4>
</li>
<li>
<h4><code><a title="pachyderm_sdk.api.pfs.file.PFSFile" href="#pachyderm_sdk.api.pfs.file.PFSFile">PFSFile</a></code></h4>
<ul class="">
<li><code><a title="pachyderm_sdk.api.pfs.file.PFSFile.readinto" href="#pachyderm_sdk.api.pfs.file.PFSFile.readinto">readinto</a></code></li>
<li><code><a title="pachyderm_sdk.api.pfs.file.PFSFile.peek" href="#pachyderm_sdk.api.pfs.file.PFSFile.peek">peek</a></code></li>
<li><code><a title="pachyderm_sdk.api.pfs.file.PFSFile.close" href="#pachyderm_sdk.api.pfs.file.PFSFile.close">close</a></code></li>
<li><code><a title="pachyderm_sdk.api.pfs.file.PFSFile.readable" href="#pachyderm_sdk.api.pfs.file.PFSFile.readable">readable</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>